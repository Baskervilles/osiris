#!/bin/bash
# vi:syntax=sh

export BUILDOPTS
export BUILDVARS
export CONFIGOPTS
export DBG
export JOBS
export LTRC_NO_RECOVERY_ON_SVC_FI
export MEMSIZE
export RELINKOPTS

: ${BUILDVARS:="-V MKMAGIC=yes -V SLOPPY_FLIST=yes"}
: ${DBG:="-O0 -g"}
: ${DISABLERECOVERY:=0}
: ${JOBS:=8}

fuse_set_fuser_conf() {
    # Path the to LLVMDataStructure.so file of DSA (built from sources from Minix repository)
    export MDSA=${CROSS_TOOLS}/../lib/LLVMDataStructure.so
    # Working directory
    export WDIR="MINIX_APPS_DIR/.fused/workdir/"
    # Path to the fused bcl file generated by "blobify scripts"
    export MINIX_SRC_BCL="$MINIX_APPS_DIR/.fused/prefixed_minix_bcl/serversblob.out.reg2mem.bcl"
    export PASSES="$ROOT/bin"
    export BIN="$WDIR/bin"
    export FMPASS="fuseminix.so"
    export FMIPASS="fusedminixinfo.so"
    export FMCPASS="fusedminixcallgraphy.so"
    # Input functions list file.
    export INPUT="$WDIR/input/fmi_functions.txt"
    export DEBUG=""
    export MINIX_SERVERS=$(ls ${OBJ}/minix/servers/)
    WDIR_VANILLA=${MINIX_APPS_DIR}/.fused/workdir/vanilla
    WDIR_PREFIXED=${MINIX_APPS_DIR}/.fused/workdir/prefixed
    WDIR_BLOBIFIED=${MINIX_APPS_DIR}/.fused/workdir/blob
    WDIR_FUSED=${MINIX_APPS_DIR}/.fused/workdir/fused
    WDIR_INFO=${MINIX_APPS_DIR}/.fused/workdir/info
    WDIR_CGINFO=${MINIX_APPS_DIR}/.fused/workdir/ccginfo

    ENDPOINT_MAP_FILE="${MINIX_ROOT}/settings.llvm/fuse/endpoints.map"
    KERNELCALL_MAP_FILE="${MINIX_ROOT}/settings.llvm/kernel_call.map"
    IDEMP_KERNELCALLERS_FILE="${MINIX_ROOT}/settings.llvm/idempotent_kernel_callers.lst"
    KERNELCALL_EXCLUDE_FILE=${WDIR_CGINFO}/kernelcall_exclusion_list
    KERNELCALL_DECISION_MAP=${WDIR_CGINFO}/kernelcall_decision_map
}

fuse_set_general_conf() {
    ARCH=i386
    export MINIX_ROOT=${MINIX_APPS_DIR}
    export OBJ=${MINIX_ROOT}/obj.${ARCH}
    export OBJ_LLVM=${MINIX_ROOT}/obj_llvm.${ARCH}
    export CROSS_TOOLS=${OBJ}/"tooldir.`uname -s`-`uname -r`-`uname -m`"/bin
    # Minix tools directory
    export MTOOLS_DIR=${CROSS_TOOLS}
    export LLVMSRCDIR=${MINIX_ROOT}/minix/external/bsd/llvm/dist/llvm
    export NETBSDSRCDIR=${MINIX_APPS_DIR}/minix/
}


fuse_set_config() {
    fuse_set_general_conf
    fuse_set_fuser_conf
}


fuse_build_dsa() {
    #we need a minix-toolchain version of
    # the data structure analysis pass
    if [[ ! "${FORCE_BUILD_DSA}" == "1" && -e ${MDSA} ]]
    then
        echo "DSA already build. Use FORCE_BUILD_DSA=1 if you want to rebuild."
    else
        $MINIX_APPS_DIR/scripts/build_minix_dsa.sh
    fi
}

fuse_create_ipc_site_map() {
    cat ${WDIR_FUSED}/log |grep IPC_CALL_TO_FUESERMAP: | awk '{printf("%s\t%s\n", $3, $2)}' >${WDIR_FUSED}/ipc_site_map
}

fuse_create_default_ipc_site_decision_map()
{
  : ${IPC_DEFAULT_DECISION:=4}
  if [ ! -d ${WDIR_CGINFO} ] ; then mkdir -p ${WDIR_CGINFO}; fi
  echo -n >${WDIR_CGINFO}/ipc_site_decision_map
  for e in `cat ${WDIR_FUSED}/ipc_site_map | tr [[:blank:]] ' ' | cut -d' ' -f1`;
  do
     echo $e $IPC_DEFAULT_DECISION >>${WDIR_CGINFO}/ipc_site_decision_map
  done
}

fuse_create_suicide_map() {
    # always suicide
    cat ${WDIR_CGINFO}/ipc_site_decision_map | sed s/\ [0-9]/\ 1/g >${WDIR_CGINFO}/suicide_map
}

fuse_create_kernelcall_decision_map() {
    : ${KC_DEFAULT_DECISION:=4}
    KC_DEFAULT_SUICIDE=1
    echo -n > ${WDIR_CGINFO}/kernelcall_decision_map
    cat ${KERNELCALL_MAP_FILE} | cut -d' ' -f2- | tr -d ' ' > ./.kc.tmp
    for e in `cat ./.kc.tmp`; do echo $e ${KC_DEFAULT_DECISION} ${KC_DEFAULT_SUICIDE} >> ${WDIR_CGINFO}/kernelcall_decision_map; done
}

fuse_create_kernelcall_exclusion_list() {
    default_list="44 4"
    echo -n "" > ${WDIR_CGINFO}/kernelcall_exclusion_list
    for e in ${default_list}; do echo $e >> ${WDIR_CGINFO}/kernelcall_exclusion_list; done
}

fuse_run_fusing_pass() {
    mkdir -p ${WDIR_FUSED}
    echo  -n "Running fusing pass... "
    if [[ ! -e ${WDIR_FUSED}/minix.bc ]]
        then
        ( cd ${WDIR_FUSED}
        ${CROSS_TOOLS}/opt \
	    -debug \
            -load $MDSA \
            -load "${ROOT}/bin/slicer.so" \
            -load "${ROOT}/bin/${FMPASS}" \
            -reg2mem \
            -fuseminix \
	    -dot-callgraph \
            -fuseminix-endpointmapfile="${ENDPOINT_MAP_FILE}" \
            ${WDIR_BLOBIFIED}/minix.bc \
            -o  ${WDIR_FUSED}/minix.bc  \
            2> ${WDIR_FUSED}/log
            if [[ "$?" -ne 0 ]]; then
                echo "Unable to move run fusing pass" >&2
                tail ${WDIR_FUSED}/log >&2
            fi
        )
            echo "done."
    else
        echo "skipped."
    fi
    fuse_create_ipc_site_map
    fuse_disassemble ${WDIR_FUSED}/minix.bc
}

# runs prefixes a single component
fuse_prefix_run_sectionify() {
    local server=$1
    local sectionify_map=".*/NULL"
    echo  -n "Runing prefixing for ${server}... "
    if [[ ! -e ${WDIR_PREFIXED}/${server}.bc ]]
        then

        ${CROSS_TOOLS}/opt -load ${ROOT}/bin/sectionify.so \
            -sectionify \
            -sectionify-prefix=${prefix}${server}_ \
            -sectionify-section-map=${sectionify_map} \
            ${WDIR_VANILLA}/${server}.bc \
            -o ${WDIR_PREFIXED}/${server}.bc
        echo "done."
    else
        echo "skipped."
    fi
}


fuse_get_vanilla_server() {
    if [[ ! -e ${WDIR_VANILLA}/${server}.bc ]]
        then
        cp ${OBJ}/minix/servers/${server}/${server}.opt.bcl \
            ${WDIR_VANILLA}/${server}.bc
    fi

}


fuse_disassemble () {
    if [[ ! -e $1.ll ]]
        then
        ${CROSS_TOOLS}/llvm-dis $1
    fi
}


fuse_prefix() {
    local prefix="mx_"
    echo Prefixing servers: ${MINIX_SERVERS}
    mkdir -p ${WDIR_VANILLA}
    mkdir -p ${WDIR_PREFIXED}
    for server in $MINIX_SERVERS
    do
        fuse_get_vanilla_server $server
        fuse_prefix_run_sectionify $server
        fuse_disassemble ${WDIR_PREFIXED}/${server}.bc
    done
}


fuse_blobify() {
    LLVMGOLD_PLUGIN=${MINIX_ROOT}/minix/minix/llvm/bin/LLVMgold.so
    mkdir -p ${WDIR_BLOBIFIED}
    echo  -n "Generating MINIX blob... "
    if [[ ! -e ${WDIR_BLOBIFIED}/minix.bc ]]
        then
        ${CROSS_TOOLS}/i586-elf32-minix-ld \
                        -nostdlib \
                        --plugin ${LLVMGOLD_PLUGIN} \
                        -r -g -plugin-opt=emit-llvm \
                        -zmuldefs \
                        ${WDIR_PREFIXED}/*.bc \
                        -o ${WDIR_BLOBIFIED}/minix.bc
        echo "done."
    else
        echo "skipped."
    fi
    fuse_disassemble ${WDIR_BLOBIFIED}/minix.bc
}

fuse_prepare_servers() {

BBCLONE_OPT=""
BBCLONE_PASS_LIST=""

C=servers $MINIX_ROOT/relink.llvm ltckpt
C=servers OPTFLAGS_APPEND="${OPT_ARGS} -load ${ROOT}/bin/slicer.so -load=$MDSA" LLVM_PASS_ARGS="${BBCLONE_OPT}" $MINIX_ROOT/build.llvm reg2mem slicer minix inlineminixipcsites mem2reg ${BBCLONE_PASS_LIST}
}

fuse_prepare_recovery() {

: ${COMP="rs pm vfs vm ds"}

# default values for optional elements
SUICIDE_OPT=""
PROFILING_OPT=""
PROFILING_PASS_LIST=""
PROFILING_STATIC_LIBS=
BBCLONE_OPT=""
BBCLONE_PASS_LIST=""
ALWAYS_INLINE_PASS=""

# Recompile the ltckpt static library so that we pick up latest compile time options
currpwd=`pwd`
 cd $ROOT/llvm/static/ltckpt
 if [ "$PERF" == 1 ]; then
	if [ "$DISABLE_LTCKPT_O3_HACK" != 1 ]
	then
		export LTCKPT_O3_HACK=1
	fi
 fi
 if [ "${TOGGLE_ENABLE_STATS}" == 1 ]; then
	echo "LTCKPT_TOGGLE_STATS on"
	export LTCKPT_TOGGLE_STATS=1
 fi

 make clean; make install
cd $currpwd

if [ ! -d ${WDIR_CGINFO} ] ; then mkdir -p ${WDIR_CGINFO}; fi
if [ ! -f ${KERNELCALL_DECISION_MAP} ] ; then fuse_create_kernelcall_decision_map; fi
if [ ! -f ${KERNELCALL_EXCLUDE_FILE} ] ; then fuse_create_kernelcall_exclusion_list; fi
if [ ! -f ${WDIR_CGINFO}/suicide_map ] ; then fuse_create_suicide_map; fi

# Option processing
if [ "${BBCLONE}" == "1" ]
then
        BBCLONE_OPT="-bbclone -bbclone-callee-mapper=0 -bbclone-exclude-callstacks-to=sef_handle_message -bbclone-flag=sa_window__is_open -bbclone-flag-value1=1 -bbclone-inline-loops=1 -bbclone-inline1=1 -bbclone-inline2=1 -bbclone-map='(^\$)|(^[^l].*\$)/^.*$/ltckpt_functions/NULL'"
	if [ "${BBCLONE_TRACE}" == "1" ]
        then
                BBCLONE_OPT="${BBCLONE_OPT} -bbclone-clone1-hookname='inc_counter_outsidewindow' -bbclone-clone2-hookname='inc_counter_inwindow'"
        fi
	BBCLONE_PASS_LIST="bbclone"
	ALWAYS_INLINE_PASS="always-inline"
fi

if [ "$1" == "suicide" ]
then
	SUICIDE_OPT="-recovery-enable-suicide"
	if [ "${SUICIDE_MAP}" != "" ]
	then
	  SUICIDE_OPT="${SUICIDE_OPT} -recovery-suicide-map-file=${SUICIDE_MAP}"
	fi
	if [ "${KERNELCALL_NO_SUICIDE}" == 1 ]
        then
	  SUICIDE="${SUICIDE_OPT} -recovery-no-suicide-on-kernelcall"
	fi
fi

if [ "$1" == "prof" ] || [ "$2" == "prof" ]
then
        #PROFILING_STATIC_LIBS="magic"
	PROFILING_OPT="-aopify-hook-args=%NUM_INSTS%,%FUNCTION_NAME% '-aopify-start-hook-map=(^\$)|(^[^l].*\$)|(^l[^t].*\$)/^.*$/ltckpt_aop_hook_wprof'"
	PROFILING_PASS_LIST="aopify aopify-block"
	C="peekfs" $MINIX_ROOT/relink.llvm magic
fi

# Relink
C=${COMP} $MINIX_ROOT/relink.llvm $RELINKOPTS ltckpt ${PROFILING_STATIC_LIBS}

COMMON_PASS_OPT=""
COMMON_PASS_LIST="reg2mem slicer minix inlineminixipcsites mem2reg ${BBCLONE_PASS_LIST}"
LTCKPT_PASS_OPT="-tol=sef_handle_message -ltckpt-method=undolog"
RECOVERY_PASS_OPT="-recovery-decision-map-file=${WDIR_CGINFO}/ipc_site_decision_map -recovery-kernelcall-exclude-file=${KERNELCALL_EXCLUDE_FILE} -recovery-kernelcall-map-file=${KERNELCALL_DECISION_MAP} $RECOVERYPASSOPTEXTRA"

if [ "$APPLY_MANUAL_DECISIONS" == "1" ] && [ -f ${IDEMP_KERNELCALLERS_FILE} ]
then
	echo "Including kernel callers idempotent markings..."
	RECOVERY_PASS_OPT="${RECOVERY_PASS_OPT} -recovery-idempotent-kernelcallers-file=${IDEMP_KERNELCALLERS_FILE}"
fi

if [ "$DISABLERECOVERY" = 0 ]; then
	COMMON_PASS_OPT="$COMMON_PASS_OPT $RECOVERY_PASS_OPT $LTCKPT_PASS_OPT"
	COMMON_PASS_LIST="$COMMON_PASS_LIST ltckpt recovery ${ALWAYS_INLINE_PASS} stats"
fi

OPT_LEVEL=
if [ "$PERF" == 1 ]; then
	OPT_LEVEL="O3"
fi

# Run instrumentaion passes
C=${COMP} OPTFLAGS_APPEND="${OPT_ARGS} -load=$MDSA" LLVM_PASS_ARGS="${COMMON_PASS_OPT} ${SUICIDE_OPT} ${PROFILING_OPT} ${BBCLONE_OPT} " OPTFLAGS_REPLACE_STRING="s/-ltckpt /-ltckptbasic /g" $MINIX_ROOT/build.llvm $OPT_LEVEL $BUILDOPTS ${COMMON_PASS_LIST} ${PROFILING_PASS_LIST}

}

fuse_action() {
    set -e
    if [ "$DEBUG" = "1" ]
        then
        set -x
    fi
    mode=$1
    shift || mode=no_action
    fuse_set_config
    echo "FUSE: executing command: ${mode}"
    case "${mode}" in
        "build_dsa")
            fuse_build_dsa
            ;;
        "prefix")
            fuse_prefix
            ;;
        "blobify")
            # link minix together in once bcl file that can be fused
            fuse_blobify
            ;;
        "clean")
            rm -rf $MINIX_ROOT/.fused
            ;;
        "fuse")
            # fuse (shortcut IPC calls) a blobified minix
            fuse_run_fusing_pass
            ;;
        "prepare_servers")
            # instrument to inline sendrec callers, add callsite ids, add recovery hooks
	    fuse_build_dsa
	    fuse_prepare_servers
	    ;;
	"prepare_analysis")
            fuse_build_dsa
            fuse_prefix
            fuse_blobify
            fuse_run_fusing_pass
            ;;
	"suicide")
            # instrument to inline sendrec callers, add callsite ids, add recovery hooks and add suicide hooks
	    SUICIDE_MAP=${WDIR_CGINFO}/suicide_map
	    RECOMPILE_LIB=1
	    fuse_prepare_recovery suicide
            ;;
	"suicide_prof")
            # instrument to inline sendrec callers, add callsite ids, add recovery hooks and add suicide hooks
	    SUICIDE_MAP=${WDIR_CGINFO}/suicide_map
	    fuse_prepare_recovery suicide prof
            ;;
	"recovery")
	    fuse_prepare_recovery
	    ;;
	"recovery_prof")
	    fuse_prepare_recovery prof
	    ;;
	"prepare_all")
	    fuse_action prepare_servers
            fuse_action prepare_analysis
	    fuse_create_default_ipc_site_decision_map
	    ;;
        "complete")
	    fuse_action prepare_servers
            fuse_action prepare_analysis
	    fuse_create_default_ipc_site_decision_map
	    fuse_action recovery
        ;;
        "rebuild_minix")
             $MINIX_ROOT/configure.llvm
        ;;
	"gen_ipc_decision_map")
	    fuse_create_default_ipc_site_decision_map
	;;
	"gen_kernelcall_decision_map")
	    fuse_create_kernelcall_decision_map
	;;
        *)
            echo "fuse_action: invalid command"
            exit 1
            ;;
    esac
}
